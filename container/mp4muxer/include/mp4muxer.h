/*
 * mp4muxer.h based on mp4v2
 *
 * Copyright (C) 2018      Steve Liu<steveliu121@163.com>
 */


#ifndef __MP4_MUXER_H
#define __MP4_MUXER_H

#include <mp4v2/mp4v2.h>

struct MP4Profile {
	char name[64];
	int video_time_scale;
	int video_sample_duration;
	int audio_time_scale;
	int audio_sample_duration;
	int width;
	int height;
	uint8_t *sps;
	uint8_t *pps;
	int sps_len;
	int pps_len;
	/* generated by [create_aac_encoder] */
	uint8_t *aac_decoder_conf;
	int aac_decoder_conf_len;
};

int create_mp4_muxer(MP4FileHandle *mp4_hd,
			MP4TrackId *video_tk, MP4TrackId *audio_tk,
			struct MP4Profile *mp4_profile);
void destroy_mp4_muxer(MP4FileHandle mp4_hd);

/* @use the current pcm frame timestamp
 * to calculate the previous aac frame's duration
 * and write the aac frame to mp4 file
 * @[mp4_pack_aac] should be called paried with [aac_encode],
 * and [mp4_pack_aac] should called before [aac_encode]
 * in order to cache timestamp to calculate duration
 */
/* XXX: [mp4_pack_aac] share the same buf with [aac_encode] */
int mp4_pack_aac(MP4FileHandle mp4_hd, MP4TrackId audio_tk, void *buf,
				int buf_len, const struct timeval *tv);

/* @h264_data: should be h264 raw data which contains sps/pps for I frame and
 * [0x00/0x00/0x00/0x01] NALU header for each NALU
 * @mp4_pack_h264: pack the previous one frame and
 * process & cache the current frame
 */
int mp4_pack_h264(MP4FileHandle mp4_hd, MP4TrackId video_tk,
				const struct timeval *tv,
				uint8_t *h264_data, int h264_data_len,
				int keyframe);

#endif
